name: Bulk Create Module Releases

on:
  workflow_dispatch:
    inputs:
      pre_release:
        description: 'Create as pre-release?'
        required: true
        type: boolean
        default: true
  push:
    branches:
      - 'v0.0.0-dev'

permissions:
  contents: write

jobs:
  release:
    name: Find and Release All Modules
    runs-on: ubuntu-latest
    outputs:
      created_tags: ${{ steps.release_step.outputs.created_tags }}
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744 # v3
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@6edd4406fa81c3da01a34fa6f6343087c207a568 # v3
        with:
          go-version: '1.25'

      - name: Find Modules, Check Tags, and Create Releases
        id: release_step # Give the step an ID to access its outputs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e # Exit immediately if a command fails
          
          # This variable will store a space-separated list of tags we successfully create
          CREATED_TAGS=""

          echo "Searching for Go modules..."
          for modfile in $(find . -name go.mod); do
            MODULE_PATH=$(dirname "$modfile")
            MODULE_PATH=${MODULE_PATH#./}

            echo "---"
            echo "Processing module at path: $MODULE_PATH"

            LATEST_TAG=$(git tag -l "$MODULE_PATH/v*" | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              echo "No version tags found for module '$MODULE_PATH'. Skipping."
              continue
            fi
            echo "Found latest tag: $LATEST_TAG"

            if gh release view "$LATEST_TAG" >/dev/null 2>&1; then
              echo "âœ… Release for tag '$LATEST_TAG' already exists. Skipping."
              continue
            fi
            echo "â—ï¸ Release for '$LATEST_TAG' does not exist. Creating one now..."

            MODULE_VERSION=${LATEST_TAG#$MODULE_PATH/}
            MODULE_NAME=$(basename "$MODULE_PATH")
            ARTIFACT_NAME="${MODULE_NAME}-${MODULE_VERSION}"
            # âœ… FIX: Use the absolute path provided by $GITHUB_WORKSPACE for reliability
            ARTIFACT_PATH="$GITHUB_WORKSPACE/${ARTIFACT_NAME}"
            
            echo "Building binary for $MODULE_NAME..."
            # Use the absolute ARTIFACT_PATH for the output
            go build -C "./$MODULE_PATH" -o "$ARTIFACT_PATH"

            # ðŸ› ï¸ NEW: Determine if this is a pre-release
            PRE_RELEASE_FLAG=""
            # The input is a string 'true' or 'false'. On a 'main' push, github.event_name is 'push'.
            if [[ "${{ github.event.inputs.pre_release }}" == "true" || "${{ github.event_name }}" == "push" ]]; then
              PRE_RELEASE_FLAG="--prerelease"
              echo "Marking release as a pre-release."
            fi

            echo "Creating GitHub release for $LATEST_TAG..."
            gh release create "$LATEST_TAG" \
              --title "$MODULE_NAME $MODULE_VERSION" \
              --notes "Automated release for module **$MODULE_PATH**." \
              --generate-notes \
              $PRE_RELEASE_FLAG \
              "$ARTIFACT_PATH"
            
            echo "Successfully created release for $LATEST_TAG."
            rm "$ARTIFACT_PATH"
            
            # ðŸ›¡ï¸ Add the successfully created tag to our list for potential rollback
            CREATED_TAGS="$CREATED_TAGS $LATEST_TAG"
          done
          echo "---"
          # Set the final list of created tags as an output for the next step
          echo "created_tags=$CREATED_TAGS" >> $GITHUB_OUTPUT
          echo "All modules processed successfully."

    # ðŸš¨ NEW JOB: This job only runs if the release job fails
  rollback_on_failure:
    name: Rollback Releases on Failure
    if: failure() && needs.release.outputs.created_tags != ''
    runs-on: ubuntu-latest
    needs: release
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Delete created releases
        run: |
          echo "ðŸš¨ A failure occurred. Rolling back successful releases from this run."
          TAGS_TO_DELETE="${{ needs.release.outputs.created_tags }}"
          for tag in $TAGS_TO_DELETE; do
            echo "Deleting release for tag: $tag"
            gh release delete "$tag" --yes
          done
          echo "Rollback complete."
